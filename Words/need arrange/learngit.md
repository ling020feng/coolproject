# learngit
# 了解Git（学自[廖雪峰老师](https://www.liaoxuefeng.com/wiki/896043488029600/896067008724000)）
###### Gir是什么?Git是   分布式版本控制系统 。
首先先了解什么是版本控制系统。根据百度百科的资料：
版本控制系统旨在解决 文件变更 的管理。这个我有体会的，在写论文的时候，更改了好几次，但是又想保留之前的文档，所以复制了好几个文档，命名为文件名加日期，这样耗费了一定的空间，而且即使已经加上了时间的标记，但是还是不会记得哪一天你做了哪些修改，稍微大点的改动，还能看一下文档明白，细微的就不记得了。还有编写代码的时候，主体方向还没有明确的时候，复制了几个工程下来进行编写，非常耗空间，麻烦，时间一长，就全部不记得了。
所以，版本控制在软件开发过程的使用由为明显。
###### 那么，它是如何规避那些麻烦的问题的呢？
需要在一台机器上当做基线机器（你也可以把自己的机器当做基线机器，谁都可以是基线机器），然后可以本地上编写完成一个版本或者一个未完成版，上传到基线机器上，这个系统会标记此次的上传信息，上传文件（上传的什么），用户名（谁上传的），说明（做了什么修改），时间（这个应该是作为主码）。这样还可以进行写作开发。大家可以进行上传，下载，系统可以标记历史修改版本的信息，可进行版本的回退。
版本控制系统主要就包括：检入检出的控制，分支和合并，历史记录。三大部分。
###### 分布式和集中式有什么区别呢？
集中式是必须规定一台机器为基线机器的，即为中央服务器，而分布式是谁都可以是基线机器，机器开了，知道他的ip和端口就可以进行上传下载，中央服务器崩了，那就干不了活了，分布式，可以等待别人上线后再进行交互，这个受点影响。就是多人协作的时候受些影响，自己开发自己的东西，完全可以进行本地版本控制。而且说是git的速度要快得多，但是没有使用过集中式的，没有这个概念。

###### 如何使用Git呢？ 
在一个文件夹内，使用git命令设定此文件夹为git仓库，即可以用来git版本控制了。
```
mkdir learngit
cd learngit
git init
```
之后会在learngit这个文件夹里生成一个.git文件，这个文件夹里面是作为git的版本控制的一些配置文件。
刚开始初始化的时候需要配置一些信息。比如这个仓库是谁的（username email），可以设定为全局，或者仅仅这个仓库，还有一些辅助工具的设定，比如代码编辑器，比较器啥的。
```
$ git config --global al user.name "xx"
$ git config --global al user.email "xx“
```
修改全局版本库用户名和email
查看所有config
```
git config --list
```
上传到仓库中：
```
git add readme.txt 
git add file1.tet file2.txt file3.txt 
git commit -m"上传了四个文件，一个是readme文件，三个是file文件"
```
上传分成两步：add  commit
只有commit了才真正传到仓库中，记性记录。

如果（第一次修改）在使用一次add后，修改后的文件加进了版本库的缓存区了，然后又修改文件（第二次修改），直接使用commit，此时只会把缓冲区中的第一次修改的文件放进master中，第二次不会放进去，除非再add一次，把第二次的放进缓冲区。

撤销修改：
1.当在工作区中的文件做出了错误的修改，但是还没有add，可以使用命令checkout命令
```
git checkout --readme.txt
```
直接放弃工作区的修改，回退回最近的一次修改（如果已经add了的话，就会回到缓冲区的那个修改）。
2.当在工作区中的文件做出了错误的修改，已经add，进入了缓冲区。使用命令回退到当前的HEAD
```
git reset HEAD readme.txt
```
此时已经把缓冲区刷新。然后就可以使用1中的checkout，把工作区的给刷新。就可以回复了。
3.已经commit了，那就回退吧。

删除：
直接使用rm进行删除，如果你之前已经把文件加入进仓库里了的话，那如果是误删，则可以使用checkout -- readme.txt进行回复，如果确实是要删除的，那就进行删除git rm readme.txt，commit -m"  delete file"进行提交。如果你使用了git rm readme.txt是误删的话，可以使用git checkout HEAD readme.txt进行回复。

使用命令status查看文件的情况
```
git status
```
可以得到文件的信息：有什么文件做出了修改，但是还没有进行add ，还没有进行commit。

使用命令diff查看文件哪里做了修改
```
git diff readme.txt
```

版本回退
使用命令log查看记录的版本，HEAD是当前版本，如果要回退，需要把HEAD指向相应的版本即可。
```
git log##查看版本记录
git reset --hard Head^   ##reset回退命令，Head表示当前版本，一个^即退一个版本，^^两个即退两个版本
```
或者直接使用commit ID号也可以。

使用命令reflog来查看之前所使用的命令历史记录，一般用来寻找commit ID号，以便更好的穿梭各个版本间。


###### 远程仓库的配置
有两种方案，一个是github提供一个免费的服务器，作为远程仓库，一定的空间，这个是大家都可以看得到的，可以进行下载，但是不能进行修改上传至这个远程仓库，但是如果你配置了ssh可以进行通信（公钥与私钥匹配），或者进行https进行通信，这样就可以进行上传修改。这个操作称为关联远程仓库。

可以使用克隆下来文件，就是平常使用github的时候，可以选择download到本地，或者clone到自己的仓库（github），现在是clone到自己的机器上。
应该是不关联也可以使用clone，只能是下载下来，还不能进行上传，也就是只能下载下来本地进行修改。要想进行上传还得关联。
>搞错了，从github上clone下来的就默认已经下载下来的本地和github上的是关联的了，不用再进行额外的关联，直接可以进行push。

使用命令进行创建公钥和私钥，在github上添加这个ssh公钥，进行识别是否是你
```
ssh-keygen -t rsa -C "email"
```
使用命令进行关联仓库
```
git remote add origin git@github.com:yourname/respositery.git
```
使用命令push上传至远程仓库
```
git push -u origin master
```
若远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，以后的推送或者拉取时就可以简化命令。
注意push的时候，是push仓库里的东西，也就是你的本地机器需要把文件add和commit后才能push。

远程克隆命令clone
```
git clone git@github.com:yourname/respositery.git
```


